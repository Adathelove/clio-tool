#!/usr/bin/env bash
# clio-browse - Interactive log browser with pull/search capabilities
#
# Usage:
#   clio-browse [--gdrive] [--onedrive] [--all] [PATH]
#
# Interactive commands:
#   next, n         - Show next log
#   prev, p         - Show previous log
#   pull            - Load content of current log into context
#   inner-find KEYWORD - Search for keyword in current and nearby logs
#   inner-forward KEYWORD - Search forward from current log
#   inner-backward KEYWORD - Search backward from current log
#   onedrive-search KEYWORD - Search in OneDrive files (not just logs)
#   list            - Show all logs again
#   jump NUMBER     - Jump to log number
#   quit, q         - Exit


SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# Global state
declare -a LOG_PATHS
declare -a LOG_DATES
declare -a LOG_PROJECTS
CURRENT_INDEX=0
TOTAL_LOGS=0
CURRENT_LOG_CONTENT=""
USE_LOCATE="${USE_LOCATE:-false}"
INCLUDE_GDRIVE="${INCLUDE_GDRIVE:-false}"
INCLUDE_ONEDRIVE="${INCLUDE_ONEDRIVE:-false}"
INCLUDE_ALL="${INCLUDE_ALL:-false}"

load_logs() {
    local start_path="${1:-$HOME}"

    echo -e "${CYAN}Loading logs from: ${BOLD}$start_path${NC}"

    if [ "$INCLUDE_ALL" = "true" ]; then
        echo -e "${DIM}Including: All cloud directories (GDrive)${NC}"
    elif [ "$INCLUDE_GDRIVE" = "true" ]; then
        echo -e "${DIM}Including: GDrive${NC}"
    fi

    echo -e "${DIM}This may take a moment...${NC}"
    echo ""

    local method_flag="--find"
    if [ "$USE_LOCATE" = "true" ]; then
        method_flag="--locate"
    fi

    # Build cloud flags
    local cloud_flags=""
    if [ "$INCLUDE_ALL" = "true" ]; then
        cloud_flags="--all"
    elif [ "$INCLUDE_GDRIVE" = "true" ]; then
        cloud_flags="--gdrive"
    fi

    # Get logs as JSON
    local logs_json=$("${SCRIPT_DIR}/find-agent-logs" $method_flag $cloud_flags "$start_path")

    # Parse JSON and populate arrays
    TOTAL_LOGS=$(echo "$logs_json" | jq -r 'length')

    if [ "$TOTAL_LOGS" -eq 0 ]; then
        echo -e "${YELLOW}No logs found in $start_path${NC}"
        exit 0
    fi

    for i in $(seq 0 $((TOTAL_LOGS - 1))); do
        LOG_PATHS[$i]=$(echo "$logs_json" | jq -r ".[$i].path")
        LOG_DATES[$i]=$(echo "$logs_json" | jq -r ".[$i].date_from_name")
        LOG_PROJECTS[$i]=$(echo "$logs_json" | jq -r ".[$i].project_dir" | xargs basename)
    done

    echo -e "${GREEN}✓ Found $TOTAL_LOGS log file(s)${NC}"
    echo ""
}

show_log_header() {
    local idx=$1

    if [ $idx -lt 0 ] || [ $idx -ge $TOTAL_LOGS ]; then
        echo -e "${RED}Invalid log index: $idx${NC}"
        return 1
    fi

    local path="${LOG_PATHS[$idx]}"
    local date="${LOG_DATES[$idx]}"
    local project="${LOG_PROJECTS[$idx]}"

    # Get file stats
    if [[ "$OSTYPE" == "darwin"* ]]; then
        local mtime=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M:%S" "$path" 2>/dev/null)
        local size=$(stat -f "%z" "$path" 2>/dev/null)
    else
        local mtime=$(stat -c "%y" "$path" 2>/dev/null | cut -d'.' -f1)
        local size=$(stat -c "%s" "$path" 2>/dev/null)
    fi

    local lines=$(wc -l < "$path" 2>/dev/null || echo "0")

    echo -e "${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BOLD}Log $((idx + 1)) of $TOTAL_LOGS${NC}"
    echo -e "${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${CYAN}Date:${NC}     $date"
    echo -e "${CYAN}Project:${NC}  $project"
    echo -e "${CYAN}Path:${NC}     $path"
    echo -e "${CYAN}Modified:${NC} $mtime"
    echo -e "${CYAN}Size:${NC}     $size bytes ($lines lines)"
    echo -e "${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
}

show_log_preview() {
    local idx=$1
    local path="${LOG_PATHS[$idx]}"

    echo -e "${DIM}Preview (first 15 lines):${NC}"
    echo ""
    head -15 "$path" | cat -n
    echo ""
    echo -e "${DIM}...${NC}"
    echo ""
}

cmd_next() {
    if [ $CURRENT_INDEX -lt $((TOTAL_LOGS - 1)) ]; then
        CURRENT_INDEX=$((CURRENT_INDEX + 1))
        CURRENT_LOG_CONTENT=""
        show_current_log
    else
        echo -e "${YELLOW}Already at last log${NC}"
    fi
}

cmd_prev() {
    if [ $CURRENT_INDEX -gt 0 ]; then
        CURRENT_INDEX=$((CURRENT_INDEX - 1))
        CURRENT_LOG_CONTENT=""
        show_current_log
    else
        echo -e "${YELLOW}Already at first log${NC}"
    fi
}

cmd_pull() {
    local path="${LOG_PATHS[$CURRENT_INDEX]}"

    echo -e "${GREEN}✓ Pulling log content into context${NC}"
    echo ""
    echo -e "${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BOLD}CONTENT: ${LOG_DATES[$CURRENT_INDEX]} - ${LOG_PROJECTS[$CURRENT_INDEX]}${NC}"
    echo -e "${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""

    cat "$path"
    echo ""
    echo -e "${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${GREEN}✓ Content loaded${NC}"

    CURRENT_LOG_CONTENT=$(cat "$path")
}

cmd_inner_find() {
    local keyword="$1"

    echo -e "${CYAN}Searching for '${BOLD}$keyword${NC}${CYAN}' in all logs...${NC}"
    echo ""

    local found=false

    for i in $(seq 0 $((TOTAL_LOGS - 1))); do
        local path="${LOG_PATHS[$i]}"
        local date="${LOG_DATES[$i]}"
        local project="${LOG_PROJECTS[$i]}"

        if grep -q -i "$keyword" "$path" 2>/dev/null; then
            found=true

            local indicator=""
            if [ $i -eq $CURRENT_INDEX ]; then
                indicator="${GREEN}[CURRENT]${NC}"
            elif [ $i -lt $CURRENT_INDEX ]; then
                indicator="${BLUE}[BEFORE]${NC}"
            else
                indicator="${MAGENTA}[AFTER]${NC}"
            fi

            echo -e "$indicator ${BOLD}Log $((i + 1)):${NC} $date - $project"
            echo -e "${DIM}$path${NC}"

            # Show matching lines with context
            grep -i -n -C 1 --color=always "$keyword" "$path" 2>/dev/null | head -10
            echo ""
        fi
    done

    if [ "$found" = false ]; then
        echo -e "${YELLOW}No matches found for '$keyword'${NC}"
    fi
}

cmd_inner_forward() {
    local keyword="$1"

    echo -e "${CYAN}Searching forward from current log for '${BOLD}$keyword${NC}${CYAN}'...${NC}"
    echo ""

    local found=false

    for i in $(seq $CURRENT_INDEX $((TOTAL_LOGS - 1))); do
        local path="${LOG_PATHS[$i]}"
        local date="${LOG_DATES[$i]}"
        local project="${LOG_PROJECTS[$i]}"

        if grep -q -i "$keyword" "$path" 2>/dev/null; then
            found=true

            local indicator=""
            if [ $i -eq $CURRENT_INDEX ]; then
                indicator="${GREEN}[CURRENT]${NC}"
            else
                indicator="${MAGENTA}[FORWARD +$((i - CURRENT_INDEX))]${NC}"
            fi

            echo -e "$indicator ${BOLD}Log $((i + 1)):${NC} $date - $project"
            echo -e "${DIM}$path${NC}"

            grep -i -n -C 1 --color=always "$keyword" "$path" 2>/dev/null | head -10
            echo ""
        fi
    done

    if [ "$found" = false ]; then
        echo -e "${YELLOW}No matches found forward for '$keyword'${NC}"
    fi
}

cmd_inner_backward() {
    local keyword="$1"

    echo -e "${CYAN}Searching backward from current log for '${BOLD}$keyword${NC}${CYAN}'...${NC}"
    echo ""

    local found=false

    for i in $(seq 0 $CURRENT_INDEX | tac); do
        local path="${LOG_PATHS[$i]}"
        local date="${LOG_DATES[$i]}"
        local project="${LOG_PROJECTS[$i]}"

        if grep -q -i "$keyword" "$path" 2>/dev/null; then
            found=true

            local indicator=""
            if [ $i -eq $CURRENT_INDEX ]; then
                indicator="${GREEN}[CURRENT]${NC}"
            else
                indicator="${BLUE}[BACKWARD -$((CURRENT_INDEX - i))]${NC}"
            fi

            echo -e "$indicator ${BOLD}Log $((i + 1)):${NC} $date - $project"
            echo -e "${DIM}$path${NC}"

            grep -i -n -C 1 --color=always "$keyword" "$path" 2>/dev/null | head -10
            echo ""
        fi
    done

    if [ "$found" = false ]; then
        echo -e "${YELLOW}No matches found backward for '$keyword'${NC}"
    fi
}

cmd_list() {
    echo -e "${BOLD}All Logs:${NC}"
    echo ""

    for i in $(seq 0 $((TOTAL_LOGS - 1))); do
        local indicator="  "
        if [ $i -eq $CURRENT_INDEX ]; then
            indicator="${GREEN}►${NC}"
        fi

        printf "$indicator ${BOLD}%3d.${NC} ${CYAN}%-12s${NC} ${DIM}%-30s${NC}\n" \
            $((i + 1)) \
            "${LOG_DATES[$i]}" \
            "${LOG_PROJECTS[$i]}"
    done
    echo ""
}

cmd_jump() {
    local target=$1

    if ! [[ "$target" =~ ^[0-9]+$ ]]; then
        echo -e "${RED}Invalid number: $target${NC}"
        return 1
    fi

    local idx=$((target - 1))

    if [ $idx -lt 0 ] || [ $idx -ge $TOTAL_LOGS ]; then
        echo -e "${RED}Log number out of range (1-$TOTAL_LOGS)${NC}"
        return 1
    fi

    CURRENT_INDEX=$idx
    CURRENT_LOG_CONTENT=""
    show_current_log
}

cmd_onedrive_search() {
    local keyword="$1"

    echo -e "${MAGENTA}=== OneDrive Search ===${NC}"
    echo -e "${CYAN}Searching ALL OneDrive files for: ${BOLD}$keyword${NC}"
    echo -e "${DIM}Note: This searches all files, not just .agent.dir/Logs${NC}"
    echo ""

    if [ ! -x "${SCRIPT_DIR}/search-onedrive" ]; then
        echo -e "${RED}Error: search-onedrive script not found${NC}"
        return 1
    fi

    "${SCRIPT_DIR}/search-onedrive" "$keyword"
}

show_current_log() {
    clear
    show_log_header $CURRENT_INDEX
    show_log_preview $CURRENT_INDEX
}

show_help() {
    cat <<EOF
${BOLD}Clio Browse - Interactive Log Browser${NC}

${BOLD}NAVIGATION:${NC}
    next, n                 - Show next log
    prev, p                 - Show previous log
    jump NUMBER             - Jump to specific log number
    list, ls                - Show all logs

${BOLD}CONTENT:${NC}
    pull                    - Load current log content
    show                    - Show current log again

${BOLD}SEARCH IN LOGS:${NC}
    inner-find KEYWORD      - Search keyword in all logs
    inner-forward KEYWORD   - Search forward from current log
    inner-backward KEYWORD  - Search backward from current log
    if KEYWORD              - Alias for inner-find
    ifw KEYWORD             - Alias for inner-forward
    ibk KEYWORD             - Alias for inner-backward

${BOLD}SEARCH IN ONEDRIVE:${NC}
    onedrive-search KEYWORD - Search ALL OneDrive files (not just logs)
    od KEYWORD              - Alias for onedrive-search

${BOLD}OTHER:${NC}
    help, h, ?              - Show this help
    quit, exit, q           - Exit browser

${BOLD}TIPS:${NC}
    - Use 'pull' to load a log before searching
    - inner-find shows matches with [BEFORE], [CURRENT], [AFTER] indicators
    - inner-forward/backward show distance from current log
    - onedrive-search is useful for finding related work outside of logs

EOF
}

# Main interactive loop
interactive_mode() {
    show_current_log

    while true; do
        echo -ne "${BOLD}${CYAN}clio-browse>${NC} "
        read -r cmd args

        case "$cmd" in
            next|n)
                cmd_next
                ;;
            prev|p)
                cmd_prev
                ;;
            pull)
                cmd_pull
                ;;
            show)
                show_current_log
                ;;
            inner-find|if)
                if [ -z "$args" ]; then
                    echo -e "${RED}Error: Keyword required${NC}"
                else
                    cmd_inner_find "$args"
                fi
                ;;
            inner-forward|ifw)
                if [ -z "$args" ]; then
                    echo -e "${RED}Error: Keyword required${NC}"
                else
                    cmd_inner_forward "$args"
                fi
                ;;
            inner-backward|ibk)
                if [ -z "$args" ]; then
                    echo -e "${RED}Error: Keyword required${NC}"
                else
                    cmd_inner_backward "$args"
                fi
                ;;
            onedrive-search|od)
                if [ -z "$args" ]; then
                    echo -e "${RED}Error: Keyword required${NC}"
                else
                    cmd_onedrive_search "$args"
                fi
                ;;
            list|ls)
                cmd_list
                ;;
            jump|j)
                if [ -z "$args" ]; then
                    echo -e "${RED}Error: Log number required${NC}"
                else
                    cmd_jump "$args"
                fi
                ;;
            help|h|\?)
                show_help
                ;;
            quit|exit|q)
                echo "Goodbye!"
                exit 0
                ;;
            "")
                continue
                ;;
            *)
                echo -e "${RED}Unknown command: $cmd${NC}"
                echo "Type 'help' for available commands"
                ;;
        esac

        echo ""
    done
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --help|-h)
            show_help
            exit 0
            ;;
        --locate)
            USE_LOCATE=true
            shift
            ;;
        --gdrive)
            INCLUDE_GDRIVE=true
            shift
            ;;
        --onedrive)
            INCLUDE_ONEDRIVE=true
            shift
            ;;
        --all)
            INCLUDE_ALL=true
            INCLUDE_GDRIVE=true
            INCLUDE_ONEDRIVE=true
            shift
            ;;
        *)
            START_PATH="$1"
            shift
            ;;
    esac
done

START_PATH="${START_PATH:-$HOME}"

# Export for subcommands
export USE_LOCATE
export INCLUDE_GDRIVE
export INCLUDE_ONEDRIVE
export INCLUDE_ALL

# Check for jq
if ! command -v jq &> /dev/null; then
    echo -e "${RED}Error: jq is required but not installed.${NC}" >&2
    echo "Install with: brew install jq" >&2
    exit 1
fi

# Load logs and start interactive mode
load_logs "$START_PATH"
interactive_mode
